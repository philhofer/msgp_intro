Go and MessagePack

Phil Hofer
@ph_hofer
http://github.com/philhofer

* Structure

- `msgp`: Why, How

- Performance comparisons

- Feature set

- Your questions and live coding

* How I Got Here

* The Standard Library Way

Declare a type in go:

	type Data struct {
		Thing string `json:"thing"`
	}

Follow with

	data, err := json.Marshal(&v)

* Why It's Great

- Declare sane data structures

- Uniform API for everything (json/xml/gob)

- Good third-party libs follow this idiom

* Why It's Awful

- Reflection is slow

- `interface{}` is sad

* I Need More Speed

* The Protocol Buffers Way

- Declare sane data type in .proto file

- Generate go code; examine output

- Weep developer tears; commit

* Why It's Great

- Speed

- Uniformity

* Why It's Awful

- Everything else

(Even Kenton Varda dislikes protocol buffers.)

* Exhibit A

.image pointers.png _ 600

* Exibit B

.image gross.png _ 600

* In Summary

- Sane (user-defined) data structures

- Speed

- Pick one

* There Is Hope

* A New Hope (July, 2014)

.image gogenerate.png 200 _

.image a-new-hope.jpg 300 _

* 'The Go Way'

* Objective

Generate fast, human-readable serialization code from existing type declarations.

* About MessagePack

- Binary, schemaless, self-describing

- Simple, _extendable_ type system (comparable to JSON)

- Compact

- Small but well-established community

* MessagePack Type System

.image msgpack.png _ 600

Map, Array, Bin, Str, Int, Uint, Float32, Float64, Bool, Nil, Extension

* Typical Use Cases

- DB -> backend -> memcached -> backend -> JSON -> frontend
 
- Redis (similar to Memcached, but can also parse MessagePack via Lua scripting)

- There _is_ an RPC spec...

* How It Works

.code main.go /START DECL OMIT/,/END DECL OMIT/

* Some Output

.code main_gen.go /START GEN OMIT/,/END GEN OMIT/

* A More Interesting Example

.code main.go /START CPT OMIT/,/END CPT OMIT/

The `msgp.Extension` interface:

	type Extension interface {
		Len() int
		ExtensionType() int8
		MarshalBinaryTo([]byte) error
		UnmarshalBinary([]byte) error
	}

* Output

.code main_gen.go /START CPTGEN OMIT/,/END CPTGEN OMIT/

* Extensions: A Quick Implementation

.code main.go /START OMIT/,/END OMIT/

* What Can We Generate?

Right now, the following:

	MarshalMsg([]byte) ([]byte, error)

	UnmarshalMsg([]byte) ([]byte, error)

	EncodeMsg(*msgp.Writer) error

	DecodeMsg(*msgp.Reader) error

	Msgsize() int


* Weird Edge Cases

- `[]byte` and `time.Time` are primitives

- Short-cut size calculations for slice/array of primitives

- Passing the concrete type of an extension by reference

Consider:

	type A struct {
		*Embedded
		B, C int
		D struct {
			E, F *A
		}
	}

* Supported types

- Builtin primitives, plus `time.Time`

- Maps with string keys

- Arrays/slices of supported types

- Structs of supported types

- Types with generated methods, or `Extension`

* Is It Fast?

.image perf.png _ 800

* What About Streams?

.image pipe.png _ 900

* How?

- Write, benchmark, repeat

- Careful attention to leaf functions (inlining)

- No unnecessary copying or allocation

- Object re-use

- Buffering (custom)

* Neat Library Features

* Errors

Inspired by `net.Error` and `syscall.OpError`:

	type Error interface {
		error
		Resumable() bool
	}

Every error that originates in `msgp` implements `Error`.

* Type Information

	func (r *Reader) NextType() (Type, error)

	func NextType(b []byte) (Type, error)

You can implement arbitrarily complex decoding procedures.

This is, effectively, how MessagePack -> JSON translation is implemented.

* Skip

	func (r *Reader) Skip() error

	func Skip(b []byte) ([]byte, error)

`Skip` is O(1) for non-composite objects.

There are also a handful of functions for manipulating raw data.

* Raw Type

	type Request struct {
		Header map[string]string
		Body   msgp.Raw
	}

`msgp.Raw` knows how to unmarshal anything into itself.

Allows for:

- Partial/lazy de-serialization

- (User-implemented) union types

- Advanced RPC semantics

* The Future

.code syn/main.go /START OMIT/,/END OMIT/




